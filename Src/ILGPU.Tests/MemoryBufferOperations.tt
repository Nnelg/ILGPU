<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="Generic/ConfigurationBase.tt" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>
using ILGPU.Runtime;
using System;
using System.Diagnostics.CodeAnalysis;
using Xunit;
using Xunit.Abstractions;

// disable: max_line_length
<#
// var copyOperations = new string[] { "CopyFrom", "CopyTo" };
var copyOperations = new string[] { };
#>
namespace ILGPU.Tests
{
    public abstract class MemoryBufferOperations : TestBase
    {
        protected MemoryBufferOperations(
            ITestOutputHelper output,
            TestContext testContext)
            : base(output, testContext)
        { }

        private static int[] InitializeArray1D(int x)
        {
            var counter = 0;
            var src = new int[x];
            for (var i = 0; i < x; i++)
                src[i] = counter++;

            return src;
        }

        [SuppressMessage(
            "Performance",
            "CA1814:Prefer jagged arrays over multidimensional",
            Justification = "Required for test cases")]
        private static int[,] InitializeArray2D(int x, int y)
        {
            var counter = 0;
            var src = new int[x, y];
            for (var i = 0; i < x; i++)
            {
                for (var j = 0; j < y; j++)
                    src[i, j] = counter++;
            }

            return src;
        }

        [SuppressMessage(
            "Performance",
            "CA1814:Prefer jagged arrays over multidimensional",
            Justification = "Required for test cases")]
        private static int[,,] InitializeArray3D(int x, int y, int z)
        {
            var counter = 0;
            var src = new int[x, y, z];
            for (var i = 0; i < x; i++)
            {
                for (var j = 0; j < y; j++)
                {
                    for (var k = 0; k < z; k++)
                        src[i, j, k] = counter++;
                }
            }

            return src;
        }

<#  foreach (var copyOperation in copyOperations) { #>
        [Theory]
        [InlineData(32)]
        [InlineData(1024)]
        public void <#= copyOperation #>1D(int x)
        {
            var extent = new Index1D(x);
            var src = InitializeArray1D(x);
            using var dst = Accelerator.Allocate1D<int>(extent);

            // Full copy
            dst.<#= copyOperation #>(src);

            // Partial copy
            var half = new Index1D(x / 2);

            dst.<#= copyOperation #>(src, new Index1D(half.X), Index1D.Zero, new Index1D(extent.X - half.X));
            dst.<#= copyOperation #>(src, new Index1D(half.X - 1), Index1D.Zero, new Index1D(extent.X - half.X));
            dst.<#= copyOperation #>(src, new Index1D(half.X + 1), Index1D.Zero, new Index1D(extent.X - (half.X + 1)));

            dst.<#= copyOperation #>(src, Index1D.Zero, new Index1D(half.X), new Index1D(extent.X - half.X));
            dst.<#= copyOperation #>(src, Index1D.Zero, new Index1D(half.X - 1), new Index1D(extent.X - half.X));
            dst.<#= copyOperation #>(src, Index1D.Zero, new Index1D(half.X + 1), new Index1D(extent.X - (half.X + 1)));

            dst.<#= copyOperation #>(src, Index1D.Zero, Index1D.Zero, new Index1D(extent.X - half.X));
            dst.<#= copyOperation #>(src, Index1D.Zero, Index1D.Zero, new Index1D(extent.X - half.X - 1));
            dst.<#= copyOperation #>(src, Index1D.Zero, Index1D.Zero, new Index1D(extent.X - half.X + 1));
        }

<#  } #>

<# foreach (var copyOperation in copyOperations) { #>
        [Theory]
        [InlineData(32, 32)]
        [InlineData(1024, 32)]
        [InlineData(1024, 1024)]
        public void <#= copyOperation #>2D(int x, int y)
        {
            var extent = new Index2D(x, y);
            var src = InitializeArray2D(x, y);
            using var dst = Accelerator.Allocate2D<int>(extent);

            // Full copy
            dst.<#= copyOperation #>(src, Index2D.Zero, Index2D.Zero, extent);

            // Partial copy
            var half = new Index2D(x / 2, y / 2);

            dst.<#= copyOperation #>(src, new Index2D(half.X, 0), Index2D.Zero, new Index2D(extent.X - half.X, extent.Y));
            dst.<#= copyOperation #>(src, new Index2D(half.X - 1, 0), Index2D.Zero, new Index2D(extent.X - half.X, extent.Y));
            dst.<#= copyOperation #>(src, new Index2D(half.X + 1, 0), Index2D.Zero, new Index2D(extent.X - (half.X + 1), extent.Y));

            dst.<#= copyOperation #>(src, new Index2D(0, half.Y), Index2D.Zero, new Index2D(extent.X, extent.Y - half.Y));
            dst.<#= copyOperation #>(src, new Index2D(0, half.Y - 1), Index2D.Zero, new Index2D(extent.X, extent.Y - half.Y));
            dst.<#= copyOperation #>(src, new Index2D(0, half.Y + 1), Index2D.Zero, new Index2D(extent.X, extent.Y - (half.Y + 1)));

            dst.<#= copyOperation #>(src, Index2D.Zero, new Index2D(half.X, 0), new Index2D(extent.X - half.X, extent.Y));
            dst.<#= copyOperation #>(src, Index2D.Zero, new Index2D(half.X - 1, 0), new Index2D(extent.X - half.X, extent.Y));
            dst.<#= copyOperation #>(src, Index2D.Zero, new Index2D(half.X + 1, 0), new Index2D(extent.X - (half.X + 1), extent.Y));

            dst.<#= copyOperation #>(src, Index2D.Zero, new Index2D(0, half.Y), new Index2D(extent.X, extent.Y - half.Y));
            dst.<#= copyOperation #>(src, Index2D.Zero, new Index2D(0, half.Y - 1), new Index2D(extent.X, extent.Y - half.Y));
            dst.<#= copyOperation #>(src, Index2D.Zero, new Index2D(0, half.Y + 1), new Index2D(extent.X, extent.Y - (half.Y + 1)));

            dst.<#= copyOperation #>(src, Index2D.Zero, Index2D.Zero, new Index2D(extent.X - half.X, extent.Y));
            dst.<#= copyOperation #>(src, Index2D.Zero, Index2D.Zero, new Index2D(extent.X - half.X - 1, extent.Y));
            dst.<#= copyOperation #>(src, Index2D.Zero, Index2D.Zero, new Index2D(extent.X - half.X + 1, extent.Y));
            dst.<#= copyOperation #>(src, Index2D.Zero, Index2D.Zero, new Index2D(extent.X, extent.Y - half.Y));
            dst.<#= copyOperation #>(src, Index2D.Zero, Index2D.Zero, new Index2D(extent.X, extent.Y - half.Y - 1));
            dst.<#= copyOperation #>(src, Index2D.Zero, Index2D.Zero, new Index2D(extent.X, extent.Y - half.Y + 1));
        }

<# } #>
<# foreach (var copyOperation in copyOperations) { #>
        [Theory]
        [InlineData(32, 32, 32)]
        [InlineData(512, 32, 32)]
        [InlineData(512, 512, 32)]
        public void <#= copyOperation #>3D(int x, int y, int z)
        {
            var extent = new Index3D(x, y, z);
            var src = InitializeArray3D(x, y, z);
            using var dst = Accelerator.Allocate1D<int>(extent);

            // Full copy
            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, extent);

            // Partial copy
            var half = new Index3D(x / 2, y / 2, z / 2);

            dst.<#= copyOperation #>(src, new Index3D(half.X, 0, 0), Index3D.Zero, new Index3D(extent.X - half.X, extent.Y, extent.Z));
            dst.<#= copyOperation #>(src, new Index3D(half.X - 1, 0, 0), Index3D.Zero, new Index3D(extent.X - half.X, extent.Y, extent.Z));
            dst.<#= copyOperation #>(src, new Index3D(half.X + 1, 0, 0), Index3D.Zero, new Index3D(extent.X - (half.X + 1), extent.Y, extent.Z));

            dst.<#= copyOperation #>(src, new Index3D(0, half.Y, 0), Index3D.Zero, new Index3D(extent.X, extent.Y - half.Y, extent.Z));
            dst.<#= copyOperation #>(src, new Index3D(0, half.Y - 1, 0), Index3D.Zero, new Index3D(extent.X, extent.Y - half.Y, extent.Z));
            dst.<#= copyOperation #>(src, new Index3D(0, half.Y + 1, 0), Index3D.Zero, new Index3D(extent.X, extent.Y - (half.Y + 1), extent.Z));

            dst.<#= copyOperation #>(src, new Index3D(0, 0, half.Z), Index3D.Zero, new Index3D(extent.X, extent.Y, extent.Z - half.Z));
            dst.<#= copyOperation #>(src, new Index3D(0, 0, half.Z - 1), Index3D.Zero, new Index3D(extent.X, extent.Y, extent.Z - half.Z));
            dst.<#= copyOperation #>(src, new Index3D(0, 0, half.Z + 1), Index3D.Zero, new Index3D(extent.X, extent.Y, extent.Z - (half.Z + 1)));

            dst.<#= copyOperation #>(src, Index3D.Zero, new Index3D(half.X, 0, 0),  new Index3D(extent.X - half.X, extent.Y, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, new Index3D(half.X - 1, 0, 0), new Index3D(extent.X - half.X, extent.Y, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, new Index3D(half.X + 1, 0, 0), new Index3D(extent.X - (half.X + 1), extent.Y, extent.Z));

            dst.<#= copyOperation #>(src, Index3D.Zero, new Index3D(0, half.Y, 0), new Index3D(extent.X, extent.Y - half.Y, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, new Index3D(0, half.Y - 1, 0), new Index3D(extent.X, extent.Y - half.Y, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, new Index3D(0, half.Y + 1, 0), new Index3D(extent.X, extent.Y - (half.Y + 1), extent.Z));

            dst.<#= copyOperation #>(src, Index3D.Zero, new Index3D(0, 0, half.Z), new Index3D(extent.X, extent.Y, extent.Z - half.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, new Index3D(0, 0, half.Z - 1), new Index3D(extent.X, extent.Y, extent.Z - half.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, new Index3D(0, 0, half.Z + 1), new Index3D(extent.X, extent.Y, extent.Z - (half.Z + 1)));

            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, new Index3D(extent.X - half.X, extent.Y, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, new Index3D(extent.X - half.X - 1, extent.Y, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, new Index3D(extent.X - half.X + 1, extent.Y, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, new Index3D(extent.X, extent.Y - half.Y, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, new Index3D(extent.X, extent.Y - half.Y - 1, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, new Index3D(extent.X, extent.Y - half.Y + 1, extent.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, new Index3D(extent.X, extent.Y, extent.Z - half.Z));
            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, new Index3D(extent.X, extent.Y, extent.Z - half.Z - 1));
            dst.<#= copyOperation #>(src, Index3D.Zero, Index3D.Zero, new Index3D(extent.X, extent.Y, extent.Z - half.Z + 1));
        }

<# } #>
    }
}